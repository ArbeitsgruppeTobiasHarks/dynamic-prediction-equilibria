\section{Computation of Multi-Commodity Equilibrium Flows}

In this section we want to discuss how we can compute an approximated variant of DPEs.
We recall from the definition, that in a DPE all infinitesimally small agents update their routing decision every time they arrive at an intermediate node.
As we are dealing with continuous flow, these routing decisions take place in a continuous manner.
To approximate this, we choose to allow updates of the routing decisions to happen at predefined intervals.
This leads to the following definition:

\begin{definition}
    Let $\varepsilon > 0$.
    A pair $(\predq, f)$ of a set of predictors $(\predq_{i,e})_{i\in I, e\in E}$ and a dynamic flow $f$ is a \emph{partial $\varepsilon$-approximated dynamic prediction equilibrium ($\varepsilon$-DPE) up to time $H\in\R\cup\{\infty\}$} if $f$ is feasible up to time $H$ and for all $e\in E, i\in I$ and $\theta < H$ it holds that
    \[
        \infl_{i,e}(\theta) > 0 \implies e \in \predE_i(\varepsilon\cdot \left\lfloor{\theta / \varepsilon}\right\rfloor, \varepsilon\cdot \left\lfloor{\theta / \varepsilon}\right\rfloor, q).
    \]
\end{definition}

To compute these kinds of dynamic flows, we begin by setting up the data structures representing dynamic flows before we have a look at the extension of feasible flows and finally how to use the predictors and the computation of dynamic shortest paths to extend the flows following the prescript in the definition of $\varepsilon$-DPEs.

Moreover, we focus on dynamic flows with right-constant flow rates only.
This means, we assume that all network inflow rates $u_i$ are right-constant.

\subsection{Extension Theorem}

Before diving into an actual program, we first consider a few theoretical observations involving the feasibility of dynamic flows.
More specifically, we want to extend partial flows with constant edge inflow rates while always preserving the feasibility properties \ref{def:feasible-flow:max-capacity}, \ref{def:feasible-flow:deterministic-split} and~\ref{def:feasible-flow:operate-at-capacity}.
By choosing appropriate edge inflow rates, we will later make sure that the flow conservation property~\ref{def:feasible-flow:flow-conservation} is fulfilled as well. 
The following theorem is the building block for the algorithms introduced in the next sections.

\begin{theorem}\label{thm:extend-edge}
    Let $f$ be a dynamic flow fulfilling properties~\ref{def:feasible-flow:max-capacity}, \ref{def:feasible-flow:deterministic-split} and~\ref{def:feasible-flow:operate-at-capacity} on an edge $e\in E$ for almost all $\theta\in\R$.
    We are given new constant inflow rates $(g_{i,e})\in\R_{\geq0}^{I}$ into $e$ beginning from time $\phi$ with $g_e \coloneqq \sum_{i\in I} g_{i,e}$.
    We partially reassign $\infl_{i,e}$ and $\outfl_{i,e}$ in the following manner:
    \begin{enumerate}[label=\textbf{Case \Roman*.}, wide=0.5em, labelwidth=4.5em]
        \item If $g_e = 0$, we set $\restrict{\outfl_{i,e}}{[T_e(\phi), \infty)} \colonequiv 0$.
        
        \item If $g_e > 0 \,\land\, \left( q_e(\phi) = 0 \,\lor\, g_e \geq \capa_e \right)$, we assign $\restrict{\outfl_{i,e}}{[T_e(\phi), \infty)} \colonequiv \min\{\capa_e, g_e\}\cdot \frac{g_{i,e}}{g_e}$.
        
        \item If $g_e \in (0, \capa_e) \,\land\, q_e(\phi) > 0$, we use $T_{\depl} \coloneqq \phi + \frac{q_e(\phi)}{\capa_e - g_e}$ for assigning
        \begin{align*}
            \restrict{\outfl_{i,e}}{[T_e(\phi), T_{\depl} + \transit_e)}
            \colonequiv \capa_e \cdot \frac{g_{i,e}}{g_e}
            \quad\text{and}\quad
            \restrict{\outfl_{i,e}}{[T_{\depl} + \transit_e, \infty)}
            \colonequiv g_{i,e}.
        \end{align*}
    \end{enumerate}
    If we additionally reassign $\restrict{\infl_{i,e}}{[\phi,\infty)} \colonequiv g_{i,e}$,
    the properties \ref{def:feasible-flow:max-capacity}, \ref{def:feasible-flow:deterministic-split} and~\ref{def:feasible-flow:operate-at-capacity} still hold on $e$ for almost all $\theta\in \R$.
\end{theorem}
\begin{proof}
    Let $f$ be the original and $h$ be the transformed dynamic flow and let $q^f$ and $q^h$ denote their corresponding queue lengths.
    We note, that $q^f$ and $q^h$ as well as $T^f$ and $T^h$ coincide on $(-\infty, \phi]$.
    Moreover, the outflow rate $\outfl[h]_e$ never exceeds $\capa_e$ and hence~\ref{def:feasible-flow:max-capacity} is fulfilled right away.
    Next, we show~\ref{def:feasible-flow:operate-at-capacity}, i.e. \[
        \outfl[h]_e(\theta) = \begin{cases}
            \capa_e, &\text{if $q^h_e(\theta - \transit_e) > 0$,} \\
            \infl[h]_e(\theta - \transit_e), &\text{otherwise.}
        \end{cases}
    \]
    For $\theta < \phi + \transit_e$, this follows solely from the properties of $f$.
    Let us analyze the case $\phi + \transit_e \leq \theta < T_e(\phi)$ or equivalently $\phi  \leq \theta - \transit_e < \phi + q_e(\phi) /\capa_e$.
    With~\ref{def:feasible-flow:max-capacity} we conclude \begin{align*}
        q_e^h(\theta - \transit_e)
        &= \int_0^{\theta-\transit_e} \infl[h]_e(t) \diff t - \int_0^{\theta} \outfl[h]_e(t) \diff t \\
        &\geq \int_0^{\phi} \infl[h]_e(t)\diff t - \int_0^{\phi + \transit_e} \outfl[h]_e \diff t
        - \capa_e\cdot (\theta - \transit_e - \phi)\\
        & = q_e(\phi) - \capa_e\cdot(\theta - \transit_e - \phi) > 0.
    \end{align*}
    With the same reasoning we infer $q_e^f(\theta - \transit_e) > 0$ and therefore $\outfl[h]_e(\theta) = \outfl[f]_e(\theta) = \capa_e$.
    Let us finally discuss the case $\theta > T_e(\phi)$;
    the point $\theta = T_e(\phi)$ can be ignored as we are only interested in almost all times.
    We distinguish between the three cases:
    \begin{enumerate}[label=\textbf{Case \Roman*.}, wide=0.5em]
        \item Here, $g_e = 0$ implies \begin{align*}
            q_e^h(\theta - \transit_e)
            = \int_0^\phi \infl[h]_e(t) \diff t - \int_0^{T_e(\phi)} \outfl[h]_e(t)\diff t
            = q_e(\phi) - \int_\phi^{\phi + q_e(\phi)/\capa_e} \outfl[h]_e(t + \transit_e)\diff t
        \end{align*}
        And as property~\ref{def:feasible-flow:operate-at-capacity} holds for $t\leq T_e(\theta)$, we infer $q_e^h(\theta - \transit_e) = q_e(\phi) - \capa_e \cdot \frac{q_e(\phi)}{\capa_e} = 0$.
        Together with $\outfl[h]_e(\theta) = 0 = \infl[h]_e(\theta - \transit_e)$ this yields the claim.

        \item We have $g_e > 0 \,\land\, \left( q_e(\phi) = 0 \,\lor\, g_e \geq \capa_e \right)$.
        Then \begin{align*}
            q_e^h(\theta - \transit_e) &= q_e(\phi) + g_e \cdot (\theta - \transit_e - \phi) - \int_{\phi + \transit_e}^{\theta} \outfl[h]_e(t)\diff t \\
            &= q_e(\phi) + g_e\cdot (\theta - \transit_e - \phi) - q_e(\phi) - (\theta - T_e(\phi))\cdot \min\{\capa_e, g_e\} \\
            &= g_e\cdot(\theta -\transit_e - \phi) - (\theta - T_e(\phi))\cdot \min\{\capa_e, g_e\}
        \end{align*}
        Let us first assume $q_e(\phi) = 0$.
        Then the above reduces to $(g_e - \min\{\capa_e,g_e\})\cdot (\theta - T_e(\phi))$ which is positive if and only if $g_e > \capa_e$ holds.
        In that case $\outfl[h]_e(\theta) = \capa_e$ holds by our assignment.
        If $q_e^h(\theta - \transit_e)$ is non-positive, we have $g_e \leq \capa_e$ which implies $\outfl[h]_e(\theta) = g_e = \infl[h]_e(\theta - \transit_e)$.

        For the case $q_e(\phi) > 0$ and $g_e \geq \capa_e$, we have \[
            q_e^h(\theta - \transit_e) = g_e\cdot(\theta - \transit_e - \phi) - (\theta - T_e(\theta)) \cdot \capa_e = (g_e - \capa_e) \cdot (\theta - \transit_e - \phi) + q_e(\phi) > 0
        \]
        and then the claim follows from $\outfl[h]_e(\theta) = \capa_e$.

        \item We do a case distinction on $\theta - \transit_e < T_{\depl}$.
        If this is true, then \begin{align*}
            q^h_e (\theta - \transit_e)
            &= q_e(\phi) + \capa_e\cdot (\phi-\theta-\transit_e) - \capa_e\cdot (\theta - \phi - \transit_e)\\
            &= q_e(\phi) - (\capa_e - g_e) \cdot (\theta - \phi - \transit_e)
            > q_e(\phi) - (\capa_e - g_e) \cdot (T_{\depl} - \phi) = 0
        \end{align*}
        Moreover, we have $\outfl[h](\theta) = \capa_e$ in this case.

        Finally, let us analyze $\theta - \transit_e \geq T_{\depl}$:
        \begin{align*}
            q^h_e (\theta - \transit_e)
            &= q^h_e(T_{\depl}) + g_e \cdot (\theta - \transit_e - T_{\depl}) - g_e \cdot (\theta - T_{\depl} - \transit_e) = q^h_e(T_{\depl})
        \end{align*}
        and by the arguments above we have $q^h_e(T_{\depl}) = 0$.
        As $\outfl[h]_e(\theta) = g_e = \infl[h]_e(\theta - \transit_e)$ holds, this completes the proof of the claim.
    \end{enumerate}

    It remains to show property~\ref{def:feasible-flow:deterministic-split}, i.e. for almost all $\theta$ and all $i\in I$ the equation
    \[
        \outfl[h]_{i,e}(\theta) = \begin{cases}
            \outfl[h]_e(\theta) \cdot \frac{\infl[h]_{i,e}(\xi)}{\infl[h]_e(\xi)}, & \text{if $\infl[h]_e(\xi) > 0$,}\\
            0, & \text{otherwise,}
        \end{cases}
    \]
    holds with $\xi\coloneqq \max \{ \xi  \mid \xi + c^h_e(\xi) = \theta \}$.
    For $\theta < T_e(\phi)$, this property is already induced by the original flow $f$.
    For $\theta > T_e(\phi)$ we have $\xi > \phi$ because of the monotonicity of $T^h_e$ and $T^h_e(\xi) = \theta > T_e(\phi)$.
    Therefore, by definition of our assignments the relations $\infl[h]_{i,e}(\xi) / \infl[h]_{i,e}(\xi)$ and $\outfl[h]_{i,e}(\theta) / \outfl[h]_{i,e}(\theta)$ coincide with $g_{i,e}/g_e$ in the case $g_e > 0$.
    For $g_e = 0$, the inflow rates $\infl[h]_{i,e}(\theta)$ and $\infl[h]_{e}(\xi)$ are zero as well.
\end{proof}

We note that in the scenario of Theorem~\ref{thm:extend-edge}, the queue $q_e$ of the transformed flow is giving for $\theta \geq \phi$ as follows:
\begin{enumerate}[wide=0.5em]
    \item[\textbf{Cases I and III.}] If we denote the depletion time by $T_{\depl} \coloneqq \phi + q_e(\phi) / (\capa_e - g_e)$, the queue lengths can be determined using \[
        q_e(\theta) = \begin{cases}
            q_e(\phi) - (\theta - \phi)\cdot (\capa_e - g_e), & \text{for $\theta \leq T_{\depl}$,}\\
            0, & \text{for $\theta \geq T_{\depl}$.}
        \end{cases}
    \]
    \item[\textbf{Case II.}] Here, no queue depletion occurs and for all $\theta \geq \phi$ we have \[
        q_e(\theta) = q_e(\phi) + (\theta - \phi)\cdot \max\{g_e - \capa_e, 0\}.
    \]
\end{enumerate}

The difference between Case I and Case III is that in Case I, $q_e(\phi) = 0$ is allowed, and thus it is possible that $T_{\depl}$ coincides with $\phi$.


\subsection{Encoding Right Constant and Piecewise Linear Functions}

Let us now discuss how the piecewise constant and piecewise linear functions are encoded.
Let $f: \R \rightarrow \R$ be a piecewise function given by \[
    f(x) \coloneqq \begin{cases}
        f(\xi_1) +  (x - \xi_1) \cdot s_f & \text{for $x < \xi_1$,} \\
        f(\xi_i) + (x - \xi_i) \cdot \frac{f(\xi_{i+1}) - f(\xi_i)}{\xi_{i+1} - \xi_i} & \text{for $\xi_i \leq x < \xi_{i+1}, i \in \firstN{k-1}$},\\
        f(\xi_k) + (x - \xi_k)\cdot s_l & \text{for $x \geq \xi_k$,}
    \end{cases}
\]
where $\xi_1 < \xi_2 < \cdots < \xi_k$ are the supporting points with $k\geq 1$, and $s_f$ and $s_l$ are the first and last slopes, respectively.
Data~Structure~\ref{data:piecewise-linear} encodes this function by saving the list $[\xi_0,\xi_1,\dots,\xi_k]$ in the attribute \code{times}, $[f(\xi_0), f(\xi_1),\dots, f(\xi_k)]$ in the attribute \code{values} and $s_f$ and $s_l$ in the attributes \code{first_slope} and \code{last_slope}.
Similarly, Data~Structure~\ref{data:right-constant} encodes a right-constant function $f:\R \rightarrow \R$ given by \[
    f(x) \coloneqq \begin{cases}
        v_f, & \text{if $x < \xi_1$ (or $k=0$),} \\
        f(\xi_i), & \text{if $\xi_i \leq x < \xi_{i+1}, i \in \firstN{k-1}$},\\
        f(\xi_k), & \text{if $x \geq \xi_k$,}
    \end{cases}
\]
where $v_f$ is written to the attribute \code{first_value}.
Here, $k=0$ is allowed.
In both cases, an evaluation of the function can be done using a simple binary search in the \code{times} array resulting in a logarithmic complexity in the time dimension $k$.

\vspace{-1em}\begin{minipage}[t]{0.5\textwidth}
\begin{classdef}[H]
    \begin{minted}[mathescape, linenos]{python}
class PiecewiseLinear:
  times: List[float]
  values: List[float]
  first_slope: float
  last_slope: float

  #  ... (methods)
\end{minted}
    \caption{\\Piecewise~Linear~Functions\vphantom{Right}}%
    \label{data:piecewise-linear}
\end{classdef}
\end{minipage}\hfill
\begin{minipage}[t]{0.5\textwidth}
\begin{classdef}[H]
    \begin{minted}[mathescape, linenos, stripnl=false]{python}
class RightConstant:
  times: List[float]
  values: List[float]
  first_value: float

  #  ... (methods)

\end{minted}
    \vspace{.084em}
    \caption{\\Right~Constant~Functions}%
    \label{data:right-constant}
\end{classdef}
\end{minipage}\vspace{1em}


In the next section, we will need the following operations on these functions.
First, we want to be able to extend a piecewise linear function $f$ beginning at some time $\theta \geq \max_{i\in\firstN{k}} \xi_i$ by some slope $s$.
This translates to Algorithm~\ref{alg:extend-piecewise-linear}.

\begin{algorithm}
  \begin{minted}[mathescape, linenos]{python}
def extend_with_slope(self, time: float, slope: float):
  if time > self.times[-1]:
    val = self.values[-1] + (time - self.times[-1]) * self.last_slope
    self.values.append(val)
    self.times.append(time)
  self.last_slope = slope
  \end{minted}
  \caption{Extension Procedure in \code{class PiecewiseLinear}}
  \label{alg:extend-piecewise-linear}
\end{algorithm}

Secondly, right constant functions should be extendable beginning from time $\theta \in\R$ with $\theta \geq \sup_{i\in\firstN{k}} \xi_i$ by some value $v\in\R$.
The corresponding procedure is shown in Algorithm~\ref{alg:extend-right-constant}.
\begin{algorithm}
  \begin{minted}[mathescape, linenos]{python}
def extend(self, time: float, value: float):
  if len(times) > 0 and time == self.times[-1]:
    self.values[-1] = value
  else:
    self.values.append(value)
    self.times.append(time)
  \end{minted}
  \caption{Extension Procedure in \code{class RightConstant}}
  \label{alg:extend-right-constant}
\end{algorithm}

We conclude this section by mentioning that these extension procedures only use constant time.

\subsection{Encoding Feasible Flows}

We now discuss the data structure used for representing and extending partial dynamic flows as defined in Data~Structure~\ref{data:flow}.

\begin{classdef}
    \begin{minted}[mathescape, linenos]{python}
class MultiComFlow
  phi: float
  inflow: Dict[Edge,List[RightConstant]]
  outflow: Dict[Edge, List[RightConstant]]
  queues: Dict[Edge, PiecewiseLinear]
  outflow_changes: PriorityQueue[Tuple[Edge, float]]
  depletions: Dict[Edge, Tuple[float, float, List[float]]]

  #  ... (methods)
\end{minted}
    \caption{Partial Dynamic Flows}
    \label{data:flow}
\end{classdef}

The horizon of such a flow, i.e. the time up to which the flow has been computed, is written to the attribute \code{phi}.
The functions $\infl_{i,e}$ and $\outfl_{i,e}$ correspond to the attributes \code{inflow[e][i]} and \code{outflow[e][i]}, respectively, both of which are objects of the class \code{RightConstant}.

Although, we could compute the queue length of an edge $e$ from these two functions on demand, we allocate 
another attribute \code{queues[e]} for the queue lengths to speed up the extension procedure.
This can be done using an object representing a piecewise linear function because it is the integral of piecewise constant functions.

Next, the priority queue \code{outflow_changes} holds all upcoming events later than \code{phi} where some edge outflow will definitely change.
It saves tuples $(e, \theta)$ with $\theta > \code{phi}$ interpreted as ``\code{outflow[e]} changes at time $\theta$''.
This helps us extend at most as long as no edge outflow rate changes.

Finally, we have a dictionary \code{depletions} which contains an edge $e$ if there is an upcoming queue depletion at some time $T_{\depl} > \phi$.
In that case, $\code{depletions[e]}$ is a tuple $(T_{\depl}, T_{\depl}+ \transit_e, (g_{i,e})_{i\in I})$ where $(g_{i,e})_{i\in I}$ is the new outflow $(\outfl_{i,e})_{i\in I}$ starting from time $T_{\depl} + \transit_e$.


\subsection{Extension of Feasible Flows}

In this section we discuss how to extend a feasible flow for some time period given new constant inflow rates on a subset of the edges.

In the beginning we usually start with an empty flow representing a feasible flow up to time $0$.
This is an object of the class \code{MultiComFlow} initialized using the operations
\begin{itemize}
\setlength{\itemsep}{0em}
\item \code{phi = 0},
\item \code{inflow[e][i] = RightConstant(times=[], values=[], first_value=0)} for all edges \code{e} and commodities \code{i},
\item \code{outflow[e][i] = RightConstant(times=[], values=[], first_value=0)} for all edges \code{e} and commodities \code{i}
\item \code{queues[e] = PiecewiseLinear(times=[0], values=[0], first_slope=0,}\\\code{last_slope=0)} for all edges \code{e},
\end{itemize}
with an empty priority queue \code{outflow_changes} and an empty dictionary \code{depletions}.

We now want to extend this initialized flow in so-called \emph{extension phases}.
That means, given a feasible flow $f$ up to time $\phi$, we want to extend this flow to a feasible flow up to time $\phi + \alpha$ for some small $\alpha > 0$.
During this extension interval $[\phi, \phi+\alpha)$ we keep all edge inflow and outflow rates constant.

We imagine a scenario in which some external mechanism determines edge inflow rates $g\in\R_{\geq 0}^{I\times E}$ to extend $f$ by $\restrict{\infl_{i,e}}{[\phi, \phi+\alpha)} \equiv g_{i,e}$ for some small $\alpha > 0$.
Moreover, we want to choose $\alpha$ at least so small, that no edge outflow rate changes within $[\phi, \phi + \alpha)$.
That way $\bal{i}{v}$ remains constant during this interval and once the node inflow $\sum_{e\in\inEdges{v}}\outfl_{i,e}$ changes, the external mechanism can react to these changes.
This enables the mechanism to preserve the flow conservation property~\ref{def:feasible-flow:flow-conservation} on intermediary nodes.

After determining the new inflow rates $(g_{i,e})_{i\in I}$ of an edge $e$ beginning at time $\phi$, we assign $\restrict{\infl_{i,e}}{[\phi,\infty)} \coloneqq g_{i,e}$.
Then we determine the outflow rate of $e$ beginning at $T_e(\phi) = \phi + \transit_e + q_e(\phi)/\capa_e$ according to properties~\ref{def:feasible-flow:deterministic-split} and~\ref{def:feasible-flow:operate-at-capacity} of Definition~\ref{def:feasible-flow}:

In the extension method we are about to introduce we want to keep track of all future changes of outflow rates of any edge.
This is done by queuing events of this type in the priority queue \code{outflow_changes}.
In all three cases \textbf{I--III} as defined in Theorem~\ref{thm:extend-edge}, the outflow of $e$ changes at time $T_e(\phi)$.
Only in case \textbf{III}, the outflow might change once again at time $T_{\depl} + \transit_e$, if during the interval $(\phi, T_{\depl})$ no other changes to the inflow of $e$ are made.
Hence, in case~\textbf{III} we record a planned change event in the dictionary \code{depletions} for edge $e$ together with the current depletion time as well as change time.

\begin{algorithm}[ht]
    \begin{minted}[linenos, escapeinside=||]{python}
def extend(
  self, new_inflow: Dict[Edge, List[float]], max_alpha: float
) -> Set[Edge]:
  for e in new_inflow.keys(): |\label{line:extendcases:0}|
    acc_in = sum(new_inflow)
    if acc_in == 0:
      self._extend_case_i(e)
    elif self.queues[e](self.phi) == 0 or acc_in > capacity[e]:
      self._extend_case_ii(e, new_inflow[e])
    else:
      self._extend_case_iii(e, new_inflow[e]) |\label{line:extendcases:1}|

  self.phi = min( |\label{line:extendalpha:0}|
    self.outflow_changes.min_key(),
    min(
      change_time for (_,change_time,_) in self.depletions.values(),
      default=float('inf')
    ),
    self.phi + max_alpha
  ) |\label{line:extendalpha:1}|

  self._process_depletions()
    
  changed_edges: Set[Edge] = set() |\label{line:returnedges:0}|
  while self.outflow_changes.min_key() <= self.phi:
      changed_edges.add(self.outflow_changes.pop()[0])
  return changed_edges |\label{line:returnedges:1}|

    \end{minted}
    \caption{Extension Procedure in \code{class MultiComFlow}}
    \label{alg:main-extend}
\end{algorithm}


The main procedure is shown in Algorithm~\ref{alg:main-extend}.
We handle the main three cases \textbf{I}, \textbf{II} and \textbf{III} in different functions, that are called in the  lines~\ref{line:extendcases:0}-\ref{line:extendcases:1}.
These functions extend the queue function \code{queues[e]} and the inflow functions \code{inflow[e][i]} starting from time \code{phi} as well as the outflow functions \code{outflow[e]} starting from time $T_{\code{e}}(\code{phi})$ for all commodities $i$.
Furthermore, they add an event to the queue \code{outflow_changes} to remember that the outflow of edge \code{e} changes at $T_{\code{e}}(\code{phi})$.
Additionally, they update the entry of $\code{e}$ in the dictionary \code{depletions} to reflect whether an upcoming queue depletion will occur with the new edge inflow rate.


Once this is done, we can determine the maximum extension span $\alpha$ and thus the new flow horizon \code{phi} as described in lines~\ref{line:extendalpha:0}-\ref{line:extendalpha:1}.
As we only want to extend at most as long as no edge outflow changes, we take the minimum of such change events.
As queue depletions induced by case~\textbf{III} may also cause outflow rate changes, we also need to consider entries of the dictionary \code{depletions} here.
Finally, we also give the external mechanism the possibility to limit this extension time using the parameter \code{max_alpha}.

\begin{algorithm}
    \begin{minted}[linenos]{python}
def _process_depletions():
  while min(
          depl_time for (depl_time,_,_) in self.depletions.values(),
          default=float('inf')
        ) <= self.phi:
    e = min(self.depletions, key=lambda e: self.depletions[e][0])
    (depl_time, change_time, new_outflow) = self.depletions.pop(e)
    self.queues[e].extend_with_slope(depl_time, 0)
    if change_time < float('inf'):
      self.outflow_changes.add((e, change_time), change_time)
      for i in range(n):
        self.outflow[e][i].extend(change_time, new_outflow[i])
\end{minted}
\caption{Procedure for Processing Queue Depletions in \code{class MultiComFlow}}
\label{alg:process-depletions}
\end{algorithm}

After determining the extension length and the new flow horizon \code{phi}, we need to process all queue depletions that happen before or at time \code{phi}.
This procedure is depicted in Algorithm~\ref{alg:process-depletions}.
For such a queue depletion of an edge \code{e}, we need to update the queue function \code{queues[e]} which will attain $0$ at its depletion time and should be extended by a $0$ slope.
Furthermore, if the queue depletion induces a change of the edge outflow rate, an appropriate event is added to the priority queue \code{outflow_changes} and the outflow functions \code{outflow[e][i]} are updated for all commodities \code{i}.

After processing all queue depletions, all edge outflow changes that will occur up to the new time horizon \code{phi} have an appropriate entry in \code{outflow_changes}.
Thus, in the main procedure in Algorithm~\ref{alg:main-extend} we can collect all edges whose outflow has changed in the returned set~\code{changed_edges}.
This is described in lines~\ref{line:returnedges:0}-\ref{line:returnedges:1}.

For completeness, we also describe the extension procedures for the three cases \textbf{I}--\textbf{III} in more detail.
Their corresponding implementations are displayed in Algorithm~\ref{alg:extend-cases}.
In all three cases, we first determine the arrival time $T_{\code{e}}(\code{phi})$ when entering the edge at the current time \code{phi} and write the result into the variable \code{arrival}.
Moreover, the pair \code{(e, arrival)} is pushed into the priority queue \code{outflow_changes}.

For case~\textbf{I}, we extend the inflow rates starting at \code{phi} and the outflow rates starting at $T_{\code{e}}(\code{phi})$ with zeros.
If the edge has a positive queue at time \code{phi}, the queue is expected to deplete at time \code{depl_time}.
If this event occurs, no further changes to the outflow rates are necessary, hence we can set the value of \code{e} in the dictionary \code{depletions} to \code{(depl_time, float('inf'), None)}.
On the other hand, if the queue is empty at time \code{phi}, we can simply remove \code{e} from the dictionary, as no depletion will occur.


The case~\textbf{II} is straight-forward:
The new outflow rate starting at $T_{\code{e}}(\code{phi})$ is calculated according to Theorem~\ref{thm:extend-edge} and the assumptions imply that no queue depletion will occur for the given inflow rates.
Hence, we do not need to update the entry of \code{e} in \code{depletions}.
Instead, if an entry of \code{e} exists, we simply remove it.

Case~\textbf{III} can only occur, if a queue depletion is expected.
Again, we calculate the outflow starting at $T_{\code{e}}(\code{phi})$ according to Theorem~\ref{thm:extend-edge} and update the entry in \code{depletions} for \code{e}:
Here, the outflow is expected to change at time $T_{\depl} + \transit_e$ once again where the new outflow rates starting from that time match the new inflow rates. 


\begin{algorithm}
    \begin{minted}[mathescape, linenos]{python}
def _extend_case_i(self, e: Edge):
  cur_queue = self.queues[e](self.phi)
  arrival = self.phi + cur_queue / capacity[e] + travel_time[e]
  self.outflow_changes.push((e, arrival), arrival)
  for i in range(n):
    self.inflow[e][i].extend(self.phi, 0)
    self.outflow[e][i].extend(arrival, 0)

  queue_slope = 0 if cur_queue == 0 else -capacity[e]
  self.queues[e].extend_with_slope(self.phi, queue_slope)
  if cur_queue > 0:
    depl_time = self.phi + cur_queue / capacity[e]
    self.depletions[e] = depl_time, float('inf'), None
  elif e in self.depletions:
    self.depletions.pop(e)


def _extend_case_ii(self, e: Edge, new_inflow: List[float]):
  # cur_queue = [...]; arrival = [...]; self.outflow_changes.push([...])
  for i in range(n):
    self.inflow[e][i].extend(self.phi, new_inflow[i])
    new_out = min(capacity[e], acc_in) * new_inflow[i] / acc_in
    self.outflow[e][i].extend(arrival, new_out)

  queue_slope = max(acc_in - capacity[e], 0)
  self.queues[e].extend_with_slope(self.phi, queue_slope)
  if e in self.depletions:
    self.depletions.pop(e)


def _extend_case_iii(self, e: Edge, new_inflow: List[float]):
  # cur_queue = [...]; arrival = [...]; self.outflow_changes.push([...])
  for i in range(n):
    self.inflow[e][i].extend(self.phi, new_inflow[i])
    new_out = capacity[e] * new_inflow[i] / acc_in
    self.outflow[e][i].extend(arrival, new_out)

  queue_slope = acc_in - capacity[e]
  self.queues[e].extend_with_slope(self.phi, queue_slope)
  depl_time = self.phi + cur_queue / (capacity[e] - acc_in)
  planned_change = depl_time + travel_time[e]
  self.depletions[e] = depl_time, planned_change, new_inflow
\end{minted}
\caption{Extension Procedure for Cases~\textbf{I}--\textbf{III} in \code{class MultiComFlow}}
\label{alg:extend-cases}
\end{algorithm}


\subsection{Computation of Approximated DPEs}

We now use the subroutine introduced in the previous section to compute $\varepsilon$-DPEs.
Here, we define the mechanism which decides how the flow is routed from its source to its sink and which defines the constant inflow rates of the extension phases.
As we want each commodity to take shortest path according to their own traffic forecast, the concept of a predictor is realized as an abstract class as shown in Data Structure~\ref{data:predictor}.


\begin{classdef}
  \begin{minted}[linenos]{python}
class Predictor(ABC):
  @abstractmethod
  def predict(self, old_queues: List[PiecewiseLinear], phi: float) \
    -> List[PiecewiseLinear]:
    pass
  
  @abstractmethod
  def is_constant(self) -> bool:
    pass
\end{minted}
\caption{The abstract \code{class Predictor}}
\label{data:predictor}
\end{classdef}

\todo[inline]{
  In section XXX, we will introduce all different predictors that have been used throughout the experiments.
}

\begin{algorithm}
  \begin{minted}[linenos]{python}
def extend_until(horizon: float) -> MultiComFlow:
  graph = self.network.graph
  travel_time = self.network.travel_time
  capacity = self.network.capacity

  while self._flow.phi < horizone:
    while self._flow.phi >= self._network_inflow_changes.min_key():
      c, t = self._network_inflow_changes.pop()
      self._handle_nodes.add(c.source)
    if self._flow.phi >= self._next_reroute_time:
      predictions = {
        key: predictor.predict_from_fcts(self._flow.queues, self._flow.phi)
        for (key, predictor) in self.predictors.items()
      }
      self._costs = {
        key: [travel_time[e] + prediction[e] / capacity[e]
              for e in range(len(graph.edges))]
        for (key, prediction) in predictions.items()
      }

      self._active_edges = [{} for _ in self.network.commodities]
      self._route_time = self._next_reroute_time
      self._next_reroute_time += self.reroute_interval
      self._handle_nodes = set(self.network.graph.nodes.values())

    new_inflow = self._determine_new_inflow()
    max_ext_time = min(
      self._next_reroute_time, self._network_inflow_changes.min_key()
    )
    changed_edges = self._flow.extend(new_inflow, max_ext_time)
    self._handle_nodes = set(
      self.network.graph.edges[e].node_to for e in changed_edges
    )

  return self._flow
\end{minted}
\caption{The abstract \code{class Predictor}}
\label{alg:extend-flow-builder}
\end{algorithm}
