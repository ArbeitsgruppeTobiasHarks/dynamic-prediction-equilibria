\section{Computation of Multi-Commodity Flows}

\subsection{Data Representation}


\begin{algorithm}
    \begin{minted}[mathescape,
        linenos,
        numbersep=5pt,
        framesep=5mm]{python}
class MultiComFlow
    phi: float
    inflow: Dict[Edge,List[RightConstant]]
    outflow: Dict[Edge, List[RightConstant]]
    queues: List[PiecewiseLinear]
    outflow_changes: PriorityQueue[Tuple[Edge, float]]
    queue_depletions: PriorityQueue[Edge]

    #  ... (methods)
    \end{minted}
\end{algorithm}




\subsection{Extension of Feasible Flows}

\begin{algorithm}

    \begin{minted}[mathescape,
        linenos,
        numbersep=5pt,
        framesep=5mm]{python}
def extend(
    self, new_inflow: Dict[Edge, List[float]], max_eps: float
) -> Set[Edge]:
    phi = self.phi
    for e in new_inflow.keys():
        acc_in, cur_queue = sum(new_inflow[e]), self.queues[e](phi)
        acc_out = min(capacity[e], acc_in)
        change_time = phi + cur_queue / capacity[e] + travel_time[e]
        for i in range(n):
            new_in = new_inflow[e][i]
            self.inflow[e][i].extend(phi, new_in)
            new_out = 0 if acc_out == 0 else acc_out * new_in / acc_in
            self.outflow[e][i].extend(change_time, new_out)
        if not self.outflow_changes.has((e, change_time)):
            self.outflow_changes.push((e, change_time), change_time)
        
        slope = max(0, acc_in - capacity[e])
                if cur_queue == 0 else
                acc_in - capacity[e]
        self.queues[e].extend_with_slope(phi, slope)
        if slope < 0:
            depletion_time = phi - cur_queue / slope
            self.queue_depletions.push_or_update(edge, depletion_time)
        elif self.queue_depletions.has(edge):
            self.queue_depletions.remove(edge)

    eps = min(self.outflow_changes.min_key() - phi, max_eps)
    self.phi = phi + eps

    while self.queue_depletions.min_key() <= self.phi:
        e, depletion_time = self.queue_depletions.pop_with_key()
        self.queues[e].extend_with_slope(depletion_time, 0.)
    
    changed_edges: Set[Edge] = set()
    while self.outflow_changes.min_key() <= self.phi:
        changed_edges.add(self.outflow_changes.pop()[0])
    return changed_edges
    \end{minted}
    \caption{Extension Procedure in \code{class MultiComFlow}}
\end{algorithm}

